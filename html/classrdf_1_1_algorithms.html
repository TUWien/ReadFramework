<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>ReadFramework: rdf::Algorithms Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ReadFramework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classrdf_1_1_algorithms.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classrdf_1_1_algorithms-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rdf::Algorithms Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains basic algorithms to manipulate images.  
 <a href="classrdf_1_1_algorithms.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_algorithms_8h_source.html">Algorithms.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac5780591c54d3cec60b405c405b89ec2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#ac5780591c54d3cec60b405c405b89ec2">MorphShape</a> { <a class="el" href="classrdf_1_1_algorithms.html#ac5780591c54d3cec60b405c405b89ec2a56f5b9bc1facb13557a3eff00da300bc">SQUARE</a> = 0, 
<a class="el" href="classrdf_1_1_algorithms.html#ac5780591c54d3cec60b405c405b89ec2a474d155e77a9eb896f3e990e3fe6a351">DISK</a>
 }</td></tr>
<tr class="separator:ac5780591c54d3cec60b405c405b89ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ea27720ef3bf555f5598b85aa41a85"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#a62ea27720ef3bf555f5598b85aa41a85">MorphBorder</a> { <a class="el" href="classrdf_1_1_algorithms.html#a62ea27720ef3bf555f5598b85aa41a85af1e8bb5b8b80673dd2f19871a32b3b3e">BORDER_ZERO</a> = 0, 
<a class="el" href="classrdf_1_1_algorithms.html#a62ea27720ef3bf555f5598b85aa41a85a5768eac63d50e5c307df8a349a14e4c4">BORDER_FLIP</a>
 }</td></tr>
<tr class="separator:a62ea27720ef3bf555f5598b85aa41a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab291874a4db55d67aea77f38fb0ccf1f"><td class="memItemLeft" align="right" valign="top">static cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#ab291874a4db55d67aea77f38fb0ccf1f">dilateImage</a> (const cv::Mat &amp;bwImg, int seSize, <a class="el" href="classrdf_1_1_algorithms.html#ac5780591c54d3cec60b405c405b89ec2">MorphShape</a> shape=<a class="el" href="classrdf_1_1_algorithms.html#ac5780591c54d3cec60b405c405b89ec2a56f5b9bc1facb13557a3eff00da300bc">Algorithms::SQUARE</a>, int borderValue=0)</td></tr>
<tr class="memdesc:ab291874a4db55d67aea77f38fb0ccf1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dilates the image bwImg with a given structuring element.  <a href="#ab291874a4db55d67aea77f38fb0ccf1f">More...</a><br/></td></tr>
<tr class="separator:ab291874a4db55d67aea77f38fb0ccf1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1aa9cb86e5b84e79967139a62fbc607"><td class="memItemLeft" align="right" valign="top">static cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#ae1aa9cb86e5b84e79967139a62fbc607">erodeImage</a> (const cv::Mat &amp;bwImg, int seSize, <a class="el" href="classrdf_1_1_algorithms.html#ac5780591c54d3cec60b405c405b89ec2">MorphShape</a> shape=<a class="el" href="classrdf_1_1_algorithms.html#ac5780591c54d3cec60b405c405b89ec2a56f5b9bc1facb13557a3eff00da300bc">Algorithms::SQUARE</a>, int borderValue=255)</td></tr>
<tr class="memdesc:ae1aa9cb86e5b84e79967139a62fbc607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erodes the image bwimg with a given structuring element.  <a href="#ae1aa9cb86e5b84e79967139a62fbc607">More...</a><br/></td></tr>
<tr class="separator:ae1aa9cb86e5b84e79967139a62fbc607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9109105fa54ab1c2ab8db5a7c68e15"><td class="memItemLeft" align="right" valign="top">static cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#a1d9109105fa54ab1c2ab8db5a7c68e15">createStructuringElement</a> (int seSize, int shape)</td></tr>
<tr class="memdesc:a1d9109105fa54ab1c2ab8db5a7c68e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the structuring element for morphological operations.  <a href="#a1d9109105fa54ab1c2ab8db5a7c68e15">More...</a><br/></td></tr>
<tr class="separator:a1d9109105fa54ab1c2ab8db5a7c68e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6728f13018d2ed6d59434e786dc311"><td class="memItemLeft" align="right" valign="top">static cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#aca6728f13018d2ed6d59434e786dc311">convolveSymmetric</a> (const cv::Mat &amp;hist, const cv::Mat &amp;kernel)</td></tr>
<tr class="memdesc:aca6728f13018d2ed6d59434e786dc311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolves a histogram symmetrically. Symmetric convolution means that the convolution is flipped around at the histograms borders. This is specifically useful for orientation histograms (since 0° corresponds to 360°  <a href="#aca6728f13018d2ed6d59434e786dc311">More...</a><br/></td></tr>
<tr class="separator:aca6728f13018d2ed6d59434e786dc311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5061644fc23f4da30ca05397eae0d6f"><td class="memItemLeft" align="right" valign="top">static cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#ac5061644fc23f4da30ca05397eae0d6f">get1DGauss</a> (double sigma)</td></tr>
<tr class="memdesc:ac5061644fc23f4da30ca05397eae0d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a 1D Gaussian filter kernel. The kernel's size is adjusted to the standard deviation.  <a href="#ac5061644fc23f4da30ca05397eae0d6f">More...</a><br/></td></tr>
<tr class="separator:ac5061644fc23f4da30ca05397eae0d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19cf68133c3d512d10e12982ee8db47"><td class="memItemLeft" align="right" valign="top">static cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#ab19cf68133c3d512d10e12982ee8db47">threshOtsu</a> (const cv::Mat &amp;srcImg, int thType=CV_THRESH_BINARY_INV)</td></tr>
<tr class="memdesc:ab19cf68133c3d512d10e12982ee8db47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threshold an image using Otsu as threshold.  <a href="#ab19cf68133c3d512d10e12982ee8db47">More...</a><br/></td></tr>
<tr class="separator:ab19cf68133c3d512d10e12982ee8db47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236d32c930edab1a4edc5fcdc8b51971"><td class="memItemLeft" align="right" valign="top">static cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#a236d32c930edab1a4edc5fcdc8b51971">convolveIntegralImage</a> (const cv::Mat &amp;src, const int kernelSizeX, const int kernelSizeY=0, <a class="el" href="classrdf_1_1_algorithms.html#a62ea27720ef3bf555f5598b85aa41a85">MorphBorder</a> norm=<a class="el" href="classrdf_1_1_algorithms.html#a62ea27720ef3bf555f5598b85aa41a85af1e8bb5b8b80673dd2f19871a32b3b3e">BORDER_ZERO</a>)</td></tr>
<tr class="memdesc:a236d32c930edab1a4edc5fcdc8b51971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolves an integral image by means of box filters. This functions applies box filtering. It is specifically useful for the computation of image sums, mean filtering and standard deviation with big kernel sizes.  <a href="#a236d32c930edab1a4edc5fcdc8b51971">More...</a><br/></td></tr>
<tr class="separator:a236d32c930edab1a4edc5fcdc8b51971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea97ec9544e8f8414bb8ea8e449e884"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#a7ea97ec9544e8f8414bb8ea8e449e884">setBorderConst</a> (cv::Mat &amp;src, float val=0.0f)</td></tr>
<tr class="memdesc:a7ea97ec9544e8f8414bb8ea8e449e884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the border to a constant value (1 pixel width).  <a href="#a7ea97ec9544e8f8414bb8ea8e449e884">More...</a><br/></td></tr>
<tr class="separator:a7ea97ec9544e8f8414bb8ea8e449e884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04af29216ee45ce3c74c500aed2d645"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#aa04af29216ee45ce3c74c500aed2d645">invertImg</a> (cv::Mat &amp;srcImg, cv::Mat mask=cv::Mat())</td></tr>
<tr class="memdesc:aa04af29216ee45ce3c74c500aed2d645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts the img.  <a href="#aa04af29216ee45ce3c74c500aed2d645">More...</a><br/></td></tr>
<tr class="separator:aa04af29216ee45ce3c74c500aed2d645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf64f1a347d5c17c57d3356472e51c0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#afdf64f1a347d5c17c57d3356472e51c0">mulMask</a> (cv::Mat &amp;src, cv::Mat mask=cv::Mat())</td></tr>
<tr class="memdesc:afdf64f1a347d5c17c57d3356472e51c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a mask to the image.  <a href="#afdf64f1a347d5c17c57d3356472e51c0">More...</a><br/></td></tr>
<tr class="separator:afdf64f1a347d5c17c57d3356472e51c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d1c5c223fee4f75c4761415e3d6c7e"><td class="memItemLeft" align="right" valign="top">static cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#af1d1c5c223fee4f75c4761415e3d6c7e">preFilterArea</a> (const cv::Mat &amp;img, int minArea, int maxArea=-1)</td></tr>
<tr class="memdesc:af1d1c5c223fee4f75c4761415e3d6c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefilters an binary image according to the blob size. Should be done to remove small blobs and to reduce the runtime of cvFindContours.  <a href="#af1d1c5c223fee4f75c4761415e3d6c7e">More...</a><br/></td></tr>
<tr class="separator:af1d1c5c223fee4f75c4761415e3d6c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47b8605d101c3484a2e84e6f5715000"><td class="memItemLeft" align="right" valign="top">static cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#ae47b8605d101c3484a2e84e6f5715000">computeHist</a> (const cv::Mat img, const cv::Mat mask=cv::Mat())</td></tr>
<tr class="memdesc:ae47b8605d101c3484a2e84e6f5715000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the histogram of an image.  <a href="#ae47b8605d101c3484a2e84e6f5715000">More...</a><br/></td></tr>
<tr class="separator:ae47b8605d101c3484a2e84e6f5715000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465a76352edb9a87f12d10e002b3c3b7"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#a465a76352edb9a87f12d10e002b3c3b7">getThreshOtsu</a> (const cv::Mat &amp;hist, const double otsuThresh=0)</td></tr>
<tr class="memdesc:a465a76352edb9a87f12d10e002b3c3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Otsu threshold based on a certain histogram.  <a href="#a465a76352edb9a87f12d10e002b3c3b7">More...</a><br/></td></tr>
<tr class="separator:a465a76352edb9a87f12d10e002b3c3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe87469e82fc6f6efbb3fa3e2a59b6c5"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#abe87469e82fc6f6efbb3fa3e2a59b6c5">normAngleRad</a> (double angle, double startIvl=0.0, double endIvl=2.0 *CV_PI)</td></tr>
<tr class="memdesc:abe87469e82fc6f6efbb3fa3e2a59b6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the normalized angle within startIvl and endIvl.  <a href="#abe87469e82fc6f6efbb3fa3e2a59b6c5">More...</a><br/></td></tr>
<tr class="separator:abe87469e82fc6f6efbb3fa3e2a59b6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a494e3ba9904e1aadc8e00b07be2d3cdd"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#a494e3ba9904e1aadc8e00b07be2d3cdd">angleDist</a> (double angle1, double angle2, double maxAngle=2.0 *CV_PI)</td></tr>
<tr class="memdesc:a494e3ba9904e1aadc8e00b07be2d3cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the distance between two angles. Hence, min(angleDiff, CV_PI*2-(angleDiff))  <a href="#a494e3ba9904e1aadc8e00b07be2d3cdd">More...</a><br/></td></tr>
<tr class="separator:a494e3ba9904e1aadc8e00b07be2d3cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2466061f1fd271a575414548d6713f53"><td class="memItemLeft" align="right" valign="top">static cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#a2466061f1fd271a575414548d6713f53">estimateMask</a> (const cv::Mat &amp;src, bool preFilter=true)</td></tr>
<tr class="memdesc:a2466061f1fd271a575414548d6713f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the mask.  <a href="#a2466061f1fd271a575414548d6713f53">More...</a><br/></td></tr>
<tr class="separator:a2466061f1fd271a575414548d6713f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a9a52098cad58ba3bd4db9bd89fade"><td class="memItemLeft" align="right" valign="top">static cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#a66a9a52098cad58ba3bd4db9bd89fade">rotateImage</a> (const cv::Mat &amp;src, double angleRad, int interpolation=cv::INTER_CUBIC, cv::Scalar borderValue=cv::Scalar(0))</td></tr>
<tr class="memdesc:a66a9a52098cad58ba3bd4db9bd89fade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates an image according to the angle obtained. The new image bounds are minimized with respect to the angle obtained. positive angle values mean counterclockwise rotation  <a href="#a66a9a52098cad58ba3bd4db9bd89fade">More...</a><br/></td></tr>
<tr class="separator:a66a9a52098cad58ba3bd4db9bd89fade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c7a0e40a6a3b9c37a10fd3155d2ba3"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#ac2c7a0e40a6a3b9c37a10fd3155d2ba3">logGammaLanczos</a> (double x)</td></tr>
<tr class="memdesc:ac2c7a0e40a6a3b9c37a10fd3155d2ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of x using the Lanczos approximation. See http ://www.rskey.org/gamma.htm  <a href="#ac2c7a0e40a6a3b9c37a10fd3155d2ba3">More...</a><br/></td></tr>
<tr class="separator:ac2c7a0e40a6a3b9c37a10fd3155d2ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0723a261ec9bc5c2e257430f68b3725c"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#a0723a261ec9bc5c2e257430f68b3725c">logGammaWindschitl</a> (double x)</td></tr>
<tr class="memdesc:a0723a261ec9bc5c2e257430f68b3725c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of x using Windschitl method.  <a href="#a0723a261ec9bc5c2e257430f68b3725c">More...</a><br/></td></tr>
<tr class="separator:a0723a261ec9bc5c2e257430f68b3725c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f098b6f2a837af192aa95df50b5f2cb"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#a1f098b6f2a837af192aa95df50b5f2cb">logGamma</a> (double x)</td></tr>
<tr class="memdesc:a1f098b6f2a837af192aa95df50b5f2cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of x.When x&gt;15 use log_gamma_windschitl(), otherwise use log_gamma_lanczos().  <a href="#a1f098b6f2a837af192aa95df50b5f2cb">More...</a><br/></td></tr>
<tr class="separator:a1f098b6f2a837af192aa95df50b5f2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e67230e106489586817acbf36edc1a6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#a2e67230e106489586817acbf36edc1a6">doubleEqual</a> (double a, double b)</td></tr>
<tr class="memdesc:a2e67230e106489586817acbf36edc1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The resulting rounding error after floating point computations depend on the specific operations done.The same number computed by different algorithms could present different rounding errors.For a useful comparison, an estimation of the relative rounding error should be considered and compared to a factor times EPS.The factor should be related to the cumulated rounding error in the chain of computation.Here, as a simplification, a fixed factor is used.  <a href="#a2e67230e106489586817acbf36edc1a6">More...</a><br/></td></tr>
<tr class="separator:a2e67230e106489586817acbf36edc1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b15f1e6a8a0063d06dc7dd79ca8bf9"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#a00b15f1e6a8a0063d06dc7dd79ca8bf9">absAngleDiff</a> (double a, double b)</td></tr>
<tr class="separator:a00b15f1e6a8a0063d06dc7dd79ca8bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f37d5d96074a9af4b8c17db07591554"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#a8f37d5d96074a9af4b8c17db07591554">signedAngleDiff</a> (double a, double b)</td></tr>
<tr class="separator:a8f37d5d96074a9af4b8c17db07591554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710f995bf54fb37f8692bb86a06d75eb"><td class="memItemLeft" align="right" valign="top">static QPointF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#a710f995bf54fb37f8692bb86a06d75eb">calcRotationSize</a> (double angleRad, const QPointF &amp;srcSize)</td></tr>
<tr class="memdesc:a710f995bf54fb37f8692bb86a06d75eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the image size of the rotated image.  <a href="#a710f995bf54fb37f8692bb86a06d75eb">More...</a><br/></td></tr>
<tr class="separator:a710f995bf54fb37f8692bb86a06d75eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01dcd7b09b95264aa391e1950e53353"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#aa01dcd7b09b95264aa391e1950e53353">min</a> (const QVector&lt; double &gt; &amp;vec)</td></tr>
<tr class="memdesc:aa01dcd7b09b95264aa391e1950e53353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum of the vector or DBL_MAX if vec is empty.  <a href="#aa01dcd7b09b95264aa391e1950e53353">More...</a><br/></td></tr>
<tr class="separator:aa01dcd7b09b95264aa391e1950e53353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e04dcdfc29867214d78553d6c941156"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#a2e04dcdfc29867214d78553d6c941156">max</a> (const QVector&lt; double &gt; &amp;vec)</td></tr>
<tr class="memdesc:a2e04dcdfc29867214d78553d6c941156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum value of vec or -DBL_MAX if vec is empty.  <a href="#a2e04dcdfc29867214d78553d6c941156">More...</a><br/></td></tr>
<tr class="separator:a2e04dcdfc29867214d78553d6c941156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e195f1402e0574e06f1aa8b7c369f5"><td class="memTemplParams" colspan="2">template&lt;typename numFmt &gt; </td></tr>
<tr class="memitem:a40e195f1402e0574e06f1aa8b7c369f5"><td class="memTemplItemLeft" align="right" valign="top">static double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#a40e195f1402e0574e06f1aa8b7c369f5">statMoment</a> (const QList&lt; numFmt &gt; &amp;valuesIn, double momentValue, int interpolated=1)</td></tr>
<tr class="memdesc:a40e195f1402e0574e06f1aa8b7c369f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes robust statistical moments (quantiles).  <a href="#a40e195f1402e0574e06f1aa8b7c369f5">More...</a><br/></td></tr>
<tr class="separator:a40e195f1402e0574e06f1aa8b7c369f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec8f775a98d0f93d4ee82edfb8f164e"><td class="memTemplParams" colspan="2">template&lt;typename sFmt , typename mFmt &gt; </td></tr>
<tr class="memitem:a4ec8f775a98d0f93d4ee82edfb8f164e"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#a4ec8f775a98d0f93d4ee82edfb8f164e">mulMaskIntern</a> (cv::Mat src, const cv::Mat mask)</td></tr>
<tr class="separator:a4ec8f775a98d0f93d4ee82edfb8f164e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6c52633a839a744021b5e080c86106"><td class="memTemplParams" colspan="2">template&lt;typename sFmt &gt; </td></tr>
<tr class="memitem:a0d6c52633a839a744021b5e080c86106"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrdf_1_1_algorithms.html#a0d6c52633a839a744021b5e080c86106">setBorderConstIntern</a> (cv::Mat src, sFmt val)</td></tr>
<tr class="separator:a0d6c52633a839a744021b5e080c86106"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains basic algorithms to manipulate images. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a62ea27720ef3bf555f5598b85aa41a85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classrdf_1_1_algorithms.html#a62ea27720ef3bf555f5598b85aa41a85">rdf::Algorithms::MorphBorder</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a62ea27720ef3bf555f5598b85aa41a85af1e8bb5b8b80673dd2f19871a32b3b3e"></a>BORDER_ZERO</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a62ea27720ef3bf555f5598b85aa41a85a5768eac63d50e5c307df8a349a14e4c4"></a>BORDER_FLIP</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ac5780591c54d3cec60b405c405b89ec2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classrdf_1_1_algorithms.html#ac5780591c54d3cec60b405c405b89ec2">rdf::Algorithms::MorphShape</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ac5780591c54d3cec60b405c405b89ec2a56f5b9bc1facb13557a3eff00da300bc"></a>SQUARE</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ac5780591c54d3cec60b405c405b89ec2a474d155e77a9eb896f3e990e3fe6a351"></a>DISK</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a00b15f1e6a8a0063d06dc7dd79ca8bf9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double rdf::Algorithms::absAngleDiff </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a494e3ba9904e1aadc8e00b07be2d3cdd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double rdf::Algorithms::angleDist </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxAngle</em> = <code>2.0*CV_PI</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the distance between two angles. Hence, min(angleDiff, CV_PI*2-(angleDiff)) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle1</td><td>The angle1.</td></tr>
    <tr><td class="paramname">angle2</td><td>The angle2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The angular distance.</dd></dl>

</div>
</div>
<a class="anchor" id="a710f995bf54fb37f8692bb86a06d75eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QPointF rdf::Algorithms::calcRotationSize </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angleRad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QPointF &amp;&#160;</td>
          <td class="paramname"><em>srcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the image size of the rotated image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angleRad</td><td>The angle in radians.</td></tr>
    <tr><td class="paramname">srcSize</td><td>Size of the source image.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Size of the rotated image.</dd></dl>

</div>
</div>
<a class="anchor" id="ae47b8605d101c3484a2e84e6f5715000"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat rdf::Algorithms::computeHist </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat&#160;</td>
          <td class="paramname"><em>mask</em> = <code>cv::Mat()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the histogram of an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>The source img CV_32FC1.</td></tr>
    <tr><td class="paramname">mask</td><td>The mask CV_8UC1 or CV_32FC1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The histogram of the img as cv::mat CV_32FC1.</dd></dl>

</div>
</div>
<a class="anchor" id="a236d32c930edab1a4edc5fcdc8b51971"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat rdf::Algorithms::convolveIntegralImage </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>kernelSizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>kernelSizeY</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrdf_1_1_algorithms.html#a62ea27720ef3bf555f5598b85aa41a85">MorphBorder</a>&#160;</td>
          <td class="paramname"><em>norm</em> = <code><a class="el" href="classrdf_1_1_algorithms.html#a62ea27720ef3bf555f5598b85aa41a85af1e8bb5b8b80673dd2f19871a32b3b3e">BORDER_ZERO</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convolves an integral image by means of box filters. This functions applies box filtering. It is specifically useful for the computation of image sums, mean filtering and standard deviation with big kernel sizes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The integral image CV_64FC1.</td></tr>
    <tr><td class="paramname">kernelSizeX</td><td>The box filter's size.</td></tr>
    <tr><td class="paramname">kernelSizeY</td><td>The box filter's size.</td></tr>
    <tr><td class="paramname">norm</td><td>If BORDER_ZERO an image sum is computed, if BORDER_FLIP a mean filtering is applied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The convolved image CV_32FC1.</dd></dl>

</div>
</div>
<a class="anchor" id="aca6728f13018d2ed6d59434e786dc311"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat rdf::Algorithms::convolveSymmetric </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convolves a histogram symmetrically. Symmetric convolution means that the convolution is flipped around at the histograms borders. This is specifically useful for orientation histograms (since 0° corresponds to 360° </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hist</td><td>The histogram CV_32FC1.</td></tr>
    <tr><td class="paramname">kernel</td><td>The convolution kernel CV_32FC1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The convolved <a class="el" href="classrdf_1_1_histogram.html">Histogram</a> CV_32FC1.</dd></dl>

</div>
</div>
<a class="anchor" id="a1d9109105fa54ab1c2ab8db5a7c68e15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat rdf::Algorithms::createStructuringElement </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the structuring element for morphological operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seSize</td><td>Size of the structuring element.</td></tr>
    <tr><td class="paramname">shape</td><td>The shape (either Square or Disk).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A cvMat containing the structuring element (CV_8UC1).</dd></dl>

</div>
</div>
<a class="anchor" id="ab291874a4db55d67aea77f38fb0ccf1f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat rdf::Algorithms::dilateImage </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>bwImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrdf_1_1_algorithms.html#ac5780591c54d3cec60b405c405b89ec2">MorphShape</a>&#160;</td>
          <td class="paramname"><em>shape</em> = <code><a class="el" href="classrdf_1_1_algorithms.html#ac5780591c54d3cec60b405c405b89ec2a56f5b9bc1facb13557a3eff00da300bc">Algorithms::SQUARE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderValue</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dilates the image bwImg with a given structuring element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bwImg</td><td>The bwImg: a grayscale image CV_8U (or CV_32F [0 1] but slower).</td></tr>
    <tr><td class="paramname">seSize</td><td>The structuring element's size.</td></tr>
    <tr><td class="paramname">shape</td><td>The shape (either Square or Disk).</td></tr>
    <tr><td class="paramname">borderValue</td><td>The border value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An dilated image (CV_8U or CV_32F).</dd></dl>

</div>
</div>
<a class="anchor" id="a2e67230e106489586817acbf36edc1a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int rdf::Algorithms::doubleEqual </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The resulting rounding error after floating point computations depend on the specific operations done.The same number computed by different algorithms could present different rounding errors.For a useful comparison, an estimation of the relative rounding error should be considered and compared to a factor times EPS.The factor should be related to the cumulated rounding error in the chain of computation.Here, as a simplification, a fixed factor is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Input a</td></tr>
    <tr><td class="paramname">b</td><td>Input b</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>equal if relative error &lt;= factor x eps</dd></dl>

</div>
</div>
<a class="anchor" id="ae1aa9cb86e5b84e79967139a62fbc607"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat rdf::Algorithms::erodeImage </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>bwImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrdf_1_1_algorithms.html#ac5780591c54d3cec60b405c405b89ec2">MorphShape</a>&#160;</td>
          <td class="paramname"><em>shape</em> = <code><a class="el" href="classrdf_1_1_algorithms.html#ac5780591c54d3cec60b405c405b89ec2a56f5b9bc1facb13557a3eff00da300bc">Algorithms::SQUARE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderValue</em> = <code>255</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erodes the image bwimg with a given structuring element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bwImg</td><td>The bwimg: a grayscale image CV_8U (or CV_32F [0 1] but slower).</td></tr>
    <tr><td class="paramname">seSize</td><td>The structuring element's size.</td></tr>
    <tr><td class="paramname">shape</td><td>The shape (either Square or Disk).</td></tr>
    <tr><td class="paramname">borderValue</td><td>The border value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An eroded image (CV_8U or CV_32F).</dd></dl>

</div>
</div>
<a class="anchor" id="a2466061f1fd271a575414548d6713f53"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat rdf::Algorithms::estimateMask </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preFilter</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Estimates the mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source image.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The estimated mask.</dd></dl>

</div>
</div>
<a class="anchor" id="ac5061644fc23f4da30ca05397eae0d6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat rdf::Algorithms::get1DGauss </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a 1D Gaussian filter kernel. The kernel's size is adjusted to the standard deviation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sigma</td><td>The standard deviation of the Gaussian.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Gaussian kernel CV_32FC1</dd></dl>

</div>
</div>
<a class="anchor" id="a465a76352edb9a87f12d10e002b3c3b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double rdf::Algorithms::getThreshOtsu </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>otsuThresh</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the Otsu threshold based on a certain histogram. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hist</td><td>The histogram CV_32FC1.</td></tr>
    <tr><td class="paramname">otsuThresh</td><td>The otsu threshold - deprecated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The computed threshold.</dd></dl>

</div>
</div>
<a class="anchor" id="aa04af29216ee45ce3c74c500aed2d645"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rdf::Algorithms::invertImg </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>srcImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>mask</em> = <code>cv::Mat()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverts the img. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcImg</td><td>The source img CV_32FC1 [0 1] or CV_8UC1.</td></tr>
    <tr><td class="paramname">mask</td><td>The mask.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1f098b6f2a837af192aa95df50b5f2cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double rdf::Algorithms::logGamma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural logarithm of the absolute value of the gamma function of x.When x&gt;15 use log_gamma_windschitl(), otherwise use log_gamma_lanczos(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The Input x.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Natural Logarithm</dd></dl>

</div>
</div>
<a class="anchor" id="ac2c7a0e40a6a3b9c37a10fd3155d2ba3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double rdf::Algorithms::logGammaLanczos </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural logarithm of the absolute value of the gamma function of x using the Lanczos approximation. See http ://www.rskey.org/gamma.htm </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Natural Algorithm</dd></dl>

</div>
</div>
<a class="anchor" id="a0723a261ec9bc5c2e257430f68b3725c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double rdf::Algorithms::logGammaWindschitl </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural logarithm of the absolute value of the gamma function of x using Windschitl method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input Value x</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Natural Log using Windschitl</dd></dl>

</div>
</div>
<a class="anchor" id="a2e04dcdfc29867214d78553d6c941156"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double rdf::Algorithms::max </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum value of vec or -DBL_MAX if vec is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>A vector with double values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the maximum</dd></dl>

</div>
</div>
<a class="anchor" id="aa01dcd7b09b95264aa391e1950e53353"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double rdf::Algorithms::min </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum of the vector or DBL_MAX if vec is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>A vector with double values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum</dd></dl>

</div>
</div>
<a class="anchor" id="afdf64f1a347d5c17c57d3356472e51c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rdf::Algorithms::mulMask </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>mask</em> = <code>cv::Mat()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a mask to the image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source img CV_8U or CV_32F.</td></tr>
    <tr><td class="paramname">mask</td><td>The optional mask CV_8U or CV_32F.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4ec8f775a98d0f93d4ee82edfb8f164e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename sFmt , typename mFmt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rdf::Algorithms::mulMaskIntern </td>
          <td>(</td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abe87469e82fc6f6efbb3fa3e2a59b6c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double rdf::Algorithms::normAngleRad </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>startIvl</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>endIvl</em> = <code>2.0*CV_PI</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the normalized angle within startIvl and endIvl. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>The angle in rad.</td></tr>
    <tr><td class="paramname">startIvl</td><td>The intervals lower bound.</td></tr>
    <tr><td class="paramname">endIvl</td><td>The intervals upper bound.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The angle within [startIvl endIvl].</dd></dl>

</div>
</div>
<a class="anchor" id="af1d1c5c223fee4f75c4761415e3d6c7e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat rdf::Algorithms::preFilterArea </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxArea</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prefilters an binary image according to the blob size. Should be done to remove small blobs and to reduce the runtime of cvFindContours. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>The source img CV_8UC1.</td></tr>
    <tr><td class="paramname">minArea</td><td>The blob size threshold in pixel.</td></tr>
    <tr><td class="paramname">maxArea</td><td>The maximum area.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A CV_8UC1 binary image with all blobs smaller than minArea removed.</dd></dl>

</div>
</div>
<a class="anchor" id="a66a9a52098cad58ba3bd4db9bd89fade"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat rdf::Algorithms::rotateImage </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angleRad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interpolation</em> = <code>cv::INTER_CUBIC</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Scalar&#160;</td>
          <td class="paramname"><em>borderValue</em> = <code>cv::Scalar(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotates an image according to the angle obtained. The new image bounds are minimized with respect to the angle obtained. positive angle values mean counterclockwise rotation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source image.</td></tr>
    <tr><td class="paramname">angleRad</td><td>The angle in RAD.</td></tr>
    <tr><td class="paramname">interpolation</td><td>The interpolation.</td></tr>
    <tr><td class="paramname">borderValue</td><td>The border value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotated image.</dd></dl>

</div>
</div>
<a class="anchor" id="a7ea97ec9544e8f8414bb8ea8e449e884"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rdf::Algorithms::setBorderConst </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>val</em> = <code>0.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the border to a constant value (1 pixel width). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source image CV_32F or CV_8U.</td></tr>
    <tr><td class="paramname">val</td><td>The border value.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d6c52633a839a744021b5e080c86106"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename sFmt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rdf::Algorithms::setBorderConstIntern </td>
          <td>(</td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sFmt&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8f37d5d96074a9af4b8c17db07591554"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double rdf::Algorithms::signedAngleDiff </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a40e195f1402e0574e06f1aa8b7c369f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename numFmt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double rdf::Algorithms::statMoment </td>
          <td>(</td>
          <td class="paramtype">const QList&lt; numFmt &gt; &amp;&#160;</td>
          <td class="paramname"><em>valuesIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>momentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interpolated</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes robust statistical moments (quantiles). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuesIn</td><td>The statistical set (samples).</td></tr>
    <tr><td class="paramname">momentValue</td><td>The statistical moment value (0.5 = median, 0.25 and 0.75 = quartiles).</td></tr>
    <tr><td class="paramname">interpolated</td><td>A flag if the value should be interpolated if the length of the list is even.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The statistical moment.</dd></dl>

</div>
</div>
<a class="anchor" id="ab19cf68133c3d512d10e12982ee8db47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat rdf::Algorithms::threshOtsu </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>srcImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thType</em> = <code>CV_THRESH_BINARY_INV</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Threshold an image using Otsu as threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcImg</td><td>The source img CV_8UC1 or CV_8UC3.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A binary image CV_8UC1</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Core/<a class="el" href="_algorithms_8h_source.html">Algorithms.h</a></li>
<li>src/Core/<a class="el" href="_algorithms_8cpp.html">Algorithms.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacerdf.html">rdf</a></li><li class="navelem"><a class="el" href="classrdf_1_1_algorithms.html">Algorithms</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
